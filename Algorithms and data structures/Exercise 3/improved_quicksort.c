#include <stdio.h>
#include <stdlib.h>
#include "improved_quicksort.h"

/* Λειτουργία: Αλγόριθμος ταξινόμησης με διαχωρισμό
Είσοδος: Ο πίνακας προς ταξινόμηση και οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς ταξινόμηση
Έξοδος: Ένας ταξινομημένος πίνακας */
void quicksort(item a[], int l, int r) {
	int i;
	/* τερματισμός αν το κομμάτι προς ταξινόμηση είναι μικρότερο ή ίσο του M */
	if (r - l <= M) 
		return;
	/* median-of-three μέθοδος */
	exch(a[(l + r) / 2], a[r - 1]);
	compexch(a[l], a[r - 1]);
	compexch(a[l], a[r]);
	compexch(a[r - 1], a[r]);
	/* διαμερισμός πίνακα */
	i = partition(a, l + 1, r - 1);
	/* αναδρομική κλήση για το πρώτο κομμάτι */
	quicksort(a, l, i - 1);
	/* αναδρομική κλήση για το δεύτερο κομμάτι */
	quicksort(a, i + 1, r);
}

/* Λειτουργία: Βοηθητική συνάρτηση διαμέρισης
Είσοδος: Ο πίνακας προς ταξινόμηση και οι δείκτες l και r που δείχνουν το κομμάτι του πίνακα προς διαμέριση
Έξοδος: Ένας πίνακας όπου τα στοιχεία το στοιχείο a[r] βρίσκεται στην τελική του θέση μέσα στον πίνακα, κανένα από τα στοιχεία a[1], ., a[r-1] δεν είναι μεγαλύτερο από το a[r] και κανένα από τα στοιχεία a[r+1], ., a[r] δεν είναι μικρότερο από το a[r]
*/
int partition(item a[], int l, int r) {
	int i = l, j = r - 1; /* δείκτες σάρωσης */
	item v = a[r]; /* δείκτης διαχωρισμού */
	while (1) { /* ατέρμων βρόγχος */
				/* μετακίνηση αριστερού δείκτη σάρωσης μέχρι να βρεθεί μεγαλύτερο ή ίσο στοιχείο */
		while (less(a[i], v)) i++;
		/* μετακίνηση δεξιού δείκτη σάρωσης μέχρι να βρεθεί μικρότερο στοιχείο ή να συναντηθούν οι δύο δείκτες */
		while (less(v, a[j])) {
			j--;
			if (j == l)
				break;
		}
		/* αν συναντήθηκαν οι δείκτες ή ο αριστερός προσπέρασε τον δεξιό, τότε ο πίνακας είναι σε τάξη */
		if (i >= j)
			break;
		/* αντιμετάθεση στοιχείων */
		exch(a[i], a[j]);
		/* κίνηση δεικτών σάρωσης κατά μία θέση */
		i++;
		j--;
	}
	/* τοποθέτηση του στοιχείου διαχωρισμού στην σωστή θέση */
	exch(a[i], a[r]);
	return i;
}

/* Λειτουργία: Αλγόριθμος ταξινόμησης με εισαγωγή (αποδοτική υλοποίηση)
Είσοδος: Ο πίνακας προς ταξινόμηση και το μέγεθος του πίνακα
Έξοδος: Ένας ταξινομημένος πίνακας */
void insertionsort_quick(item *a, int n) {
	int i, j;
	item temp;
	/* μετακίνηση του μικρότερου στοιχείου στην αρχή του πίνακα για να παίξει το ρόλο φρουρού */
	for (i = 1; i < n; i++) {
		compexch(a[i], a[0]);
	}
	/* ταξινόμηση όλων των αντικειμένων */
	for (i = 2; i < n; i++) {
		j = i;
		temp = a[i];
		/* σύγκριση του αντικειμένου i με όλα τα αντικείμενα στα αριστερά του μέχρι να βρει το πρώτο μεγαλύτερο αντικείμενο */
		while (less(temp, a[j - 1])) {
			a[j] = a[j - 1];
			j--;
		}
		a[j] = temp;
	}
}

/* Λειτουργία: Συνάρτηση ταξινόμησης
Είσοδος: Ο πίνακας και το μέγεθος του πίνακα
Έξοδος: Ένας ταξινομημένος πίνακας */
void sort(item *a, int n) {
	quicksort(a, 0, n - 1);
	insertionsort(a, n);
}

/* Λειτουργία: Εκτύπωση στοιχείων πίνακα
Είσοδος: Ο πίνακας και το μέγεθος του πίνακα
Έξοδος: - */
void display_arr(item *a, int n) {
	int i;
	printf("-----\n");
	for (i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}
	printf("\n-----\n");
}
